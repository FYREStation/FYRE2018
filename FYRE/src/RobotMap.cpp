// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "WPILib.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<frc::SpeedController> 	RobotMap::pIDDriveSystemLeftDriveMotor;
std::shared_ptr<frc::SpeedController> 	RobotMap::pIDDriveSystemRightDriveMotor;
std::shared_ptr<frc::RobotDrive> 		RobotMap::pIDDriveSystemDriveSystem;
std::shared_ptr<frc::Encoder> 			RobotMap::pIDDriveSystemLeftDriveEncoder;
std::shared_ptr<frc::Encoder> 			RobotMap::pIDDriveSystemRightDriveEncoder;
std::shared_ptr<frc::AnalogInput> 		RobotMap::pIDDriveSystemLeftSideDistanceSensor;
std::shared_ptr<frc::AnalogInput> 		RobotMap::pIDDriveSystemRightSideDistanceSensor;
std::shared_ptr<frc::SpeedController> 	RobotMap::pIDLiftSystemLiftMotor;
std::shared_ptr<frc::AnalogInput> 		RobotMap::pIDLiftSystemLiftDistanceSensor;
std::shared_ptr<frc::SpeedController> 	RobotMap::armSystemLeftArmMotor;
std::shared_ptr<frc::SpeedController> 	RobotMap::armSystemRightArmMotor;
std::shared_ptr<frc::SpeedController> 	RobotMap::armSystemHingeMotor;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

/* Initializes the mappings for the electronics. This is meant for the LiveWindow present in the Test Mode (enabled via the dashboard) */
void RobotMap::init()
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

	/* Creates a Live Window (not sure what this is)*/
    frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

    ///* Drive System*///

    /* Adds the Left Drive Motor to the Live Window (PWM 0)*/
    pIDDriveSystemLeftDriveMotor.reset(new frc::Spark(0));
    lw->AddActuator("PIDDriveSystem", "Left Drive Motor", std::static_pointer_cast<frc::Spark>(pIDDriveSystemLeftDriveMotor));
    
    /* Adds the Right Drive Motor to the Live Window (PWM 1)*/
    pIDDriveSystemRightDriveMotor.reset(new frc::Spark(1));
    lw->AddActuator("PIDDriveSystem", "Right Drive Motor", std::static_pointer_cast<frc::Spark>(pIDDriveSystemRightDriveMotor));
    
    /* Resets the Drive System (not sure why) */
    pIDDriveSystemDriveSystem.reset(new frc::RobotDrive(pIDDriveSystemLeftDriveMotor, pIDDriveSystemRightDriveMotor));
    
    /* Sets various settings for the Drive System) */
    pIDDriveSystemDriveSystem->SetSafetyEnabled(true);
    pIDDriveSystemDriveSystem->SetExpiration(0.1);
    pIDDriveSystemDriveSystem->SetSensitivity(0.5);
    pIDDriveSystemDriveSystem->SetMaxOutput(1.0);
    pIDDriveSystemDriveSystem->SetInvertedMotor(frc::RobotDrive::kRearRightMotor, true);

    /* Adds the Left Drive Encoder to the Live Window (Digital 0 and 1)*/
    pIDDriveSystemLeftDriveEncoder.reset(new frc::Encoder(0, 1, false, frc::Encoder::k4X));
    lw->AddSensor("PIDDriveSystem", "Left Drive Encoder", pIDDriveSystemLeftDriveEncoder);
    pIDDriveSystemLeftDriveEncoder->SetDistancePerPulse(1.0);
    pIDDriveSystemLeftDriveEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);

    /* Adds the Right Drive Encoder to the Live Window (Digital 2 and 3)*/
    pIDDriveSystemRightDriveEncoder.reset(new frc::Encoder(2, 3, false, frc::Encoder::k4X));
    lw->AddSensor("PIDDriveSystem", "Right Drive Encoder", pIDDriveSystemRightDriveEncoder);
    pIDDriveSystemRightDriveEncoder->SetDistancePerPulse(1.0);
    pIDDriveSystemRightDriveEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);

    /* Adds the Left Distance Sensor to the Live Window (Analog 1)*/
    pIDDriveSystemLeftSideDistanceSensor.reset(new frc::AnalogInput(1));
    lw->AddSensor("PIDDriveSystem", "Left Side Distance Sensor", pIDDriveSystemLeftSideDistanceSensor);
    
    /* Adds the Right Distance Sensor to the Live Window (Analog 2) */
    pIDDriveSystemRightSideDistanceSensor.reset(new frc::AnalogInput(2));
    lw->AddSensor("PIDDriveSystem", "Right Side Distance Sensor", pIDDriveSystemRightSideDistanceSensor);
    
    ///* End of Drive System *///

    ///* Lift System *///

    /* Adds the Lift Motor to the Live Window (PWM 2) */
    pIDLiftSystemLiftMotor.reset(new frc::Spark(2));
    lw->AddActuator("PIDLiftSystem", "Lift Motor", std::static_pointer_cast<frc::Spark>(pIDLiftSystemLiftMotor));
    
    /* Adds the Lift Distance Sensor to the Live Window (Analog 0) */
    pIDLiftSystemLiftDistanceSensor.reset(new frc::AnalogInput(0));
    lw->AddSensor("PIDLiftSystem", "Lift Distance Sensor", pIDLiftSystemLiftDistanceSensor);
    
    ///* End of Lift System *///

    ///* Arm System *///

    /* Adds the Left Arm Motor to the Live Window (PWM 3) */
    armSystemLeftArmMotor.reset(new frc::Spark(3));
    lw->AddActuator("ArmSystem", "Left Arm Motor", std::static_pointer_cast<frc::Spark>(armSystemLeftArmMotor));
    
    /* Adds the Right Arm Motor to the Live Window (PWM 4) */
    armSystemRightArmMotor.reset(new frc::Spark(4));
    lw->AddActuator("ArmSystem", "Right Arm Motor", std::static_pointer_cast<frc::Spark>(armSystemRightArmMotor));
    
    /* Adds the Hinge Motor to the Live Window (PWM 5) */
    armSystemHingeMotor.reset(new frc::Spark(5));
    lw->AddActuator("ArmSystem", "Hinge Motor", std::static_pointer_cast<frc::Spark>(armSystemHingeMotor));
    
    ///* End of Arm System *///

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
