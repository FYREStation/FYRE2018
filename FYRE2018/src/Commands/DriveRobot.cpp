// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "DriveRobot.h"
#include "../Robot.h"
#include "Joystick.h"

DriveRobot::DriveRobot(): frc::Command()
{
	Requires(Robot::driveTrain.get());
}

// Called just before this Command runs the first time
void DriveRobot::Initialize()
{
	Robot::driveTrain->haltDriving();
}

// Called repeatedly when this Command is scheduled to run
void DriveRobot::Execute()
{
	if ( Robot::driveTrain->getDriveMethod() == false )
	{
		Robot::driveTrain->driveLeftSide( tankDrive( true ) );
		Robot::driveTrain->driveRightSide( tankDrive( false ) );
	}
	else
	{
		Robot::driveTrain->driveLeftSide( arcadeDrive( true ) );
		Robot::driveTrain->driveRightSide( arcadeDrive( false ) );
	}
}

// Make this return true when this Command no longer needs to run execute()
bool DriveRobot::IsFinished()
{
	if ( IsTimedOut() == true )
	{
		return true;
	}
		else
	{
		return false;
	}
}

// Called once after isFinished returns true
void DriveRobot::End()
{
	Robot::driveTrain->haltDriving();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveRobot::Interrupted()
{
	End();
}

double DriveRobot::tankDrive( bool left )
{
	double deadzone = 0.20;

	Robot::oi->getXBox()->SetXChannel(1);
	Robot::oi->getXBox()->SetYChannel(5);

	double leftStick = Robot::oi->getXBox()->GetX();
	double rightStick = Robot::oi->getXBox()->GetY();

	Robot::oi->getXBox()->SetThrottleChannel(2);
	double leftThrottle = Robot::oi->getXBox()->GetThrottle();

	Robot::oi->getXBox()->SetThrottleChannel(3);
	double rightThrottle = Robot::oi->getXBox()->GetThrottle();

	double throttle= 0.0;
	if ( leftThrottle > rightThrottle )
	{
		throttle = leftThrottle;
	}
	else
	{
		throttle = rightThrottle;
	}

	double delta = 0.10;

	if ( ( leftStick >= -deadzone ) && ( leftStick <= deadzone ) )
	{
		leftStick = 0.0;
	}
	if ( ( rightStick >= -deadzone ) && ( rightStick <= deadzone ) )
	{
		rightStick = 0.0;
	}
	throttle = ( ( throttle * 0.5 ) + 0.5 );
	double maxSpeed = 1.0; // for encoder use

	// TankDrive
	double diff = leftStick - rightStick;
	if ( abs(diff) < delta )
	{
		return ( ( leftStick + rightStick ) / 2 ) * throttle * maxSpeed;
	}
	else if ( left == true )
	{
		return leftStick * throttle * maxSpeed;
	}
	else
	{
		return rightStick * throttle * maxSpeed;
	}

}

double DriveRobot::arcadeDrive( bool left )
{
	double deadzone = 0.20;

    Robot::oi->getXBox()->SetXChannel(0);
    Robot::oi->getXBox()->SetYChannel(1);

	double leftXAxis = Robot::oi->getXBox()->GetX();
	double leftYAxis = Robot::oi->getXBox()->GetY();

	if ( ( leftXAxis >= -deadzone ) && ( leftXAxis <= deadzone ) )
	{
		leftXAxis = 0.0;
	}
	if ( ( leftYAxis >= -deadzone ) && ( leftYAxis <= deadzone ) )
	{
		leftYAxis = 0.0;
	}

	Robot::oi->getXBox()->SetXChannel(4);
	Robot::oi->getXBox()->SetYChannel(5);

	double rightXAxis = Robot::oi->getXBox()->GetX();
	double rightYAxis = Robot::oi->getXBox()->GetY();

	if ( ( rightXAxis >= -deadzone ) && ( rightXAxis <= deadzone ) )
	{
		rightXAxis = 0.0;
	}
	if ( ( rightYAxis >= -deadzone ) && ( rightYAxis <= deadzone ) )
	{
		rightYAxis = 0.0;
	}

	double xAxis, yAxis;

	if ( leftXAxis == 0.0 && leftYAxis == 0.0 )
	{
		xAxis = rightXAxis;
		yAxis = rightYAxis;
	}
	else
	{
		xAxis = leftXAxis;
		yAxis = leftYAxis;
	}

	xAxis = -0.7 * xAxis; // flips and scales down the xAxis

	Robot::oi->getXBox()->SetThrottleChannel(2);
	double leftThrottle = Robot::oi->getXBox()->GetThrottle();

	Robot::oi->getXBox()->SetThrottleChannel(3);
	double rightThrottle = Robot::oi->getXBox()->GetThrottle();

	double throttle= 0.0;
	if ( leftThrottle > rightThrottle )
	{
		throttle = leftThrottle;
	}
	else
	{
		throttle = rightThrottle;
	}

	throttle = ( ( throttle * 0.5 ) + 0.5 );
	double maxSpeed = 1.0; // for encoder use

	// Arcade Drive
	if ( left == true )
	{
		double val = yAxis + xAxis;
		if ( val < -1 )
		{
			val = -1;
		}
		else if ( val > 1 )
		{
			val = 1;
		}
		return val * throttle * maxSpeed;
	}
	else
	{
		double val = yAxis - xAxis;
		if ( val < -1 )
		{
			val = -1;
		}
		else if ( val > 1 )
		{
			val = 1;
		}
		return val * throttle * maxSpeed;
	}
}
